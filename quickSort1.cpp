// 4. 퀵 정렬
// 3 7 8 1 5 9 6 10 2 4
// 가장 앞에 있는 수를 pivot(기준 값)으로 많이 한다. 왼쪽에서는 3보다 큰 값을, 오른쪽에서는 3보다 작은 값을
// 3 2 8 1 5 9 6 10 7 4
// 3 2 1 8 5 9 6 10 7 4 이쪽에서 8과 1은 엇갈렸다. 이제 작은 값의 인덱스가 큰 값의 인덱스보다 더 작은 것이다. -> 엇갈림
// 엇갈린 상황에서는 작은 값과 pivot을 바꿔준다.
// 1 2 3 8 5 9 6 10 7 4 이렇게 3의 왼쪽의 수들은 3보다 작고, 오른쪽은 3보다 크다. -> 분할
// 왼쪽은 작고 오른쪽은 크다는 특징이 있다. 이제 왼쪽과 오른쪽 따로따로 반복적으로 퀵 정렬을 수행해준다.
// 왼쪽에서는 가장 작은 값 1이 pivot이 되는 것이다. 오른쪽은 8이 pivot 값이다.
// 1과 자기 자신을 바꾼다. -> 엇갈림. 이제 2도 데이터 한개이기 떄문에 그대로 내비둠.
// 1 2 3 8 5 4 6 10 7 9
// 1 2 3 8 5 4 6 7 10 9 -> 엇갈림
// 1 2 3 7 5 4 6 8 10 9 -> 8을 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽에 있다.
// 1 2 3 7 5 4 6 8 10 9 -> 7 5 4 6 과 10 9 각각 퀵 정렬 진행
// 7 5 4 6 은 7과 6 엇갈림.
// 1 2 3 6 5 4 7 8 10 9 이제 쭈욱 진행하면 된다. 반씩 조깬다는 의미로 logN이라 한다.
// 7을 기준으로 왼쪽 6 5 4, 오른쪽 8 10 9 각각 퀵 정렬을 진행하면 된다.
// 왼쪽 6 5 4는 6이 pivot이 되어 진행한다. 오른쪽에서는 작은 값 4에서 멈춤, 4와 7 사이에 공간에 왼쪽에서 출발한
// index가 존재한다고 생각하자. -> 엇갈림 -> pivot과 작은 값을 바꿔준다.
// 1 2 3 4 5 6 7 8 10 9 -> 10과 9를 퀵 정렬 진행한다.
#include <iostream>
#include <algorithm>

using namespace std;

int arr[] = {5, 1, 9, 2, 8, 6, 7, 4, 3, 10};
int size = 10;

void quickSort(int *arr, int start, int end){
    if (start >= end) return; // 기본적으로 원소가 한개인 경우에 해당한다.
    int pivot = start; // pivot 값을 맨 처음으로 선택한다.
    int i = start+1, j = end, temp;

    while(i <= j){ // 엇 갈릴 때까지 반복, 엇 갈리게 되면 이 부분을 탈출
        while(i <= end && arr[i] <= arr[pivot]) i++; // 그럼 작을때까지 반복? 그럼 큰거 만나면 멈추는 걸로?
        // i가 key 값 보다 작다면 i를 한 칸씩 오른쪽으로 이동 시켜준다. 즉, key 값 보다 큰 것을 만날 때까지
        while(j > start && arr[j] >= arr[pivot]) j--;
        // j가 key 값 보다 크거나 같다면 왼쪽으로 이동 시켜준다.

        if(i > j){ // 현재 엇갈린 상태면 key 값과 교체한다.
            swap(arr[j], arr[pivot]);
            //temp = arr[j];
            //arr[j] = arr[pivot];
            //arr[pivot] = temp;
        }
        else{
            swap(arr[i], arr[j]);
            //temp = arr[i];
            //arr[i] = arr[j];
            //arr[j] = temp;
        }
    }
    quickSort(arr, start, j - 1);
    quickSort(arr, j + 1, end);
    // 123 7 5 4 6 8 10 9에서 8보다 작은건 7 5 4 6, 8보다 큰건 10 9에서
    // 8은 j에 해당한다. 따라서 start는 7이고 j - 1은 6에 해당
    // j + 1은 10에 해당 end는 9에 해당한다.
}

int main(){
    quickSort(arr, 0, size - 1);
    for(int i = 0; i < 10; i++){
        cout << arr[i] << ' ';
    }
    return 0;
}
// 이미 정렬이 되어 있는 1, 2, 3, 4, 5, 6, 7, 8, 9, 10의 경우 n^2이다.
// 삽입 정렬이 더 빠를 수가 있다. 누가 더 빠른지 구분하는 것은 의미 x
// 정렬할 데이터의 특성에 따라 적절한 알고리즘을 사용하는 것이 가장 중요하다.
// 정렬이 되어 있는 경우 삽입 정렬이 더 빠를 수 있다.
// 내림차순 정렬은 >=, <=을 바꾸면 된다.



